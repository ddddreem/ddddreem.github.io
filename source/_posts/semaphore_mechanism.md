---
title: 操作系统信号量机制
date: 2022-10-25 15:25:11
tags: 
- basicfour
- os
- 进程管理
---

# 信号量机制

![image-20221028090936462](./img/image-20221028090936462.png)

进程互斥的四种软件实现方式：**单标志法**、**双标志先检查法**，**双标志后检查法**、**Peterson算法**

进程互斥的三种硬件实现方法：**中断屏蔽方法**、**TS/TSL指令**、**Swap/XCHG指令**

1. 在双标志先检查法中，进入区的 “检查”，“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；
2. 所有的解决方案都无法实现 “让权等待”（如果进程暂时不能进入临界区，则让出处理机资源）。

因此，Dijkstra提出实现进程同步、互斥的方法-------<font color=red size=4>**信号量机制**</font>

## 介绍

​	用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。

​	<font color=blue size=4>**信号量**</font>其实就是一个变量（<font color=blue size=4>**可以是一个整数，也可以是更复杂的记录型变量**</font>），可以同一个信号量来<font color=blue size=4>**表示系统中某种资源的数量**</font>，比如：系统中只有一台打印机，就可以设置一个初值为 1的信号量。

​	<font color=blue size=4>**原语是一种特殊的程序段**</font>，其执行只能一气呵成，不能被打断。原语是<font color=blue size=4>**由 关中断/开中断指令实现的**</font>。软件解决方案的主要问题是由 “进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用 “原语”实现，使这些操作能 “一气呵成”就能避免问题。

一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal ，括号里的信号量 S 其实就是函数调用时传入的一个参数。

<font color=blue size=4>**wait、signal 原语常简称为 P、V 操作。因此，wait(S)、signal(S)分别写为 P(S)、V(S)。**</font>

## 整型信号量

用一个<font color=blue size=4>**整数型的变量**</font>作为信号量，用来<font color=blue size=4>**表示系统中某种资源的数量。（只能对整型信号量进行 初始化、P操作、V操作）**</font>

```c++
int S = 1; // 初始化整型信号量S，表示当前系统中可用的打印机资源数量

void wait(int S){ // wait 原语，相当于 “进入区”
    while(S <= 0); // 如果资源数不够，就一直循环等待
    S = S - 1; // 如果资源数够，则占用一个资源
}

void signal(int S){ // signal原语，相当于 “退出区”
    S = S + 1; // 使用完资源后，在退出去释放资源
}

进程P0;
...
wait(S); // 进入区，申请资源
使用打印机资源... // 临界区，访问资源
signal(S); // 退出区，释放资源
...
    
    
进程P1;
...
wait(S);
使用打印机资源...
signal(S);
...
```

其中，wait 原语中检查和上锁是一气呵成的，所以避免了并发、异步导致的问题

存在的问题：<font color=blue size=4>**不满足 “让权等待”原则， 会发生 “忙等”**</font>。即当有一个进程进入临界区之后，另一个进程会一直在做循环，而不会放弃处理机资源。

## 记录型信号量

使用整型信号量时，会出现 “忙等”的问题。因此记录型信号量就是用来解决 “忙等”问题。

```c++
// 记录型信号量的定义
typedef struct{
	int value; // 剩余资源数
	struct process* L; // 等待队列
} semaphore;

// 某进程需要使用资源时，通过 wait原语申请
void wait(semaphore S){
    S.value--;
    if (S.value < 0){
        block(S.L);
    }
}

// 进程使用完资源，通过 signal原语释放
void signal(semaphore S){
    S.value++;
    if (S.value <= 0){
        wakeup(S.L);
    }
}
```

<font color=blue size=4>**wait原语：**</font>如果剩余的资源数不够，即当`S.value-- < 0`时，说明现在临界区的资源不够分配给进程使用，则当前进程和后来的进程依次被阻塞并进入阻塞队列`block(S.L)`（运行态 --> 阻塞态）。

<font color=blue size=4>**signal原语：**</font>当进程使用完资源之后，通过signal原语归还一个临界区资源，即`S.value++`，当归还一个临界区资源之后，`S.value `还是小于等于 0时，说明有进程在等待这个资源并却有进程在阻塞队列，因此需要在等待队列中唤醒一个等待进程（阻塞态 --> 就绪态）。

## 信号量机制实现互斥

1. 分析并发进程的关键活动，划定临界区（如：比临界资源打印机的访问就应放在临界区）
2. 设置<font color=blue size=4>**互斥信号量 mutex，初值为 1**</font>
3. 在<font color=blue size=4>**临界区之前执行 P(mutex)**</font>
4. 在<font color=blue size=4>**临界区之后执行 V(mutex)**</font>

```c++
// 信号量机制实现互斥
semaphore mutex = 1; // 初始化信号量

P1(){
	...
	P(mutex); // 使用临界资源前要加锁
	临界区代码段...
	V(mutex); // 使用完临界资源之后需解锁，允许其他需要临界资源的进程获取资源
	...
}

P2(){
	...
	P(mutex);
	临界区代码段...
	V(mutex);
	...
}
```

<font color=blue size=4>**注：**</font>对**不同的临界资源需要设置不同的互斥信号量。**

​	**P、V操作必须成对出现**。缺少P(mutex)就不能保证临界资源的互斥访问；缺少 V(mutex)会导致资源永不释放，等待进程永不被唤醒。

## 信号量机制实现同步

1. 分析什么地方需要实现 “同步关系”，即必须保证 “一前一后”执行的两个操作（或两句代码）
2. 设置<font color=blue size=4>**同步信号量 S，初识为 0**</font>
3. <font color=blue size=4>**在需要先执行的操作之后执行 V(S)**</font>
4. <font color=blue size=4>**在后面执行的操作之前执行 P(S)**</font>

```c++
// 信号量机制实现同步
semaphore S = 0; // 初始化同步信号量，初始化为0

P1(){
	代码1;
	代码2;
	V(S);
	代码3;
}

P2(){
	P(S);
	代码4;
	代码5;
	代码6;
}
```

上诉代码表示：在执行 代码4之前，代码1和代码2已经完成。

## 信号量机制实现前驱关系

​	实质上就是多个同步问题，只需要根据需求设置多个同步信号量，根据先后关系设置 P、V操作的位置。<font color=blue size=4>**为每一对前驱关系各设置一个同步变量。**</font>