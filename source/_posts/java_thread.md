---
title: Java多线程温习
date: 2022-10-25 15:00:11
tags: 
- java
- Thread
---

# Java多线程

## 实现

通过<font color=blue>**继承Thread类和实现Runnable接口来创建线程本质上是没有区别的**</font>，从源码上看，我们可以很清晰的看到，实现Runnable的类不能自己创建一个线程，只能通过Thread构造器来创建一个线程。

实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。

![image-20221025151607054](./img/image-20221025151607054.png)

<font color=blue size=3>**注：**</font>用关键字native修饰的方法为底层调用方法，一般是当前操作系统提供给应用程序的程序接口，应用程序请求操作系统为其提供服务，由于某些服务必须工作在内核态，即操作CPU、内存和 I/O设备；因此必须由用户态切换到内核态，这就涉及到系统调用。

这里Thread类的start()方法是创建一个线程的入口，但是真正创建线程的方法是本地方法 start0()。

![image-20221025151853380](./img/image-20221025151853380.png)

调用 start0()方法后，操作系统为当前进程创建一个新的线程，这个线程由操作系统来决定执行的时间。由操作系统来统一调度。

线程执行时，调用的业务逻辑即是重写的 run()方法中的业务逻辑。

![image-20221025152711777](./img/image-20221025152711777.png)

## 为什么实现Runnable接口的类也必须通过Thread类来创建一个线程呢？

根据继承关系，Thread类是继承Runnable接口的，Thread类中的 run()方法其实是实现了Runnable接口中的 run()方法。

如果一个类仅仅是实现了Runnable接口，这个类自身是没有创建一个线程的方法的，Java中的Thread类为我们提供了创建一个新线程的方法，也不用我们自己写创建线程的方法，只需要通过传参的方式调用 Thread类中的构造方法，由于Thread类中有一个

![image-20221025153014448](./img/image-20221025153014448.png)

![image-20221025153449308](./img/image-20221025153449308.png)

传入实现Runnable接口的类对象即可生成一个Thread类，这个线程调用的 run()即是这个类对象重写的 run()方法

![image-20221025153536821](./img/image-20221025153536821.png)

<font color=blue size=3>**注：**</font>当实现了Runnable接口的类对象直接在 main主线程中调用 run()方法时，这个时候会被当成是一个普通方法，并不会为他新开一个线程，相当于当前线程还是串行的、顺序的执行，在 run()方法后的 main主线程代码必须等待 run()方法执行结束之后才能执行。

![image-20221025155004002](./img/image-20221025155004002.png)

<!-- more -->

## 新线程跟main线程是什么关系？

首先，一个 Java程序，也就是一个 Java进程在运行时就会创建一个 main()进程，这个进程是 Java程序的入口线程，而在 main线程里又可以创建其他新线程，新创建出来的线程和 main线程是同等级的，也就是说，当 main线程结束之后，其他的新建线程可能还没结束，并不是说 main线程结束之后 Java进程就结束了。

![image-20221025154243135](./img/image-20221025154243135.png)

## 线程常用方法

![image-20221025163521021](./img/image-20221025163521021.png)

![image-20221025163540796](./img/image-20221025163540796.png)

interrupt：只是中断在休眠的线程，即立马唤醒正在休眠的线程，并不是直接结束这个线程。

![image-20221025164302355](./img/image-20221025164302355.png)

join：调用 join的进程一定要执行完，一定会成功，yield方法不一定会礼让成功

![image-20221025165253684](./img/image-20221025165253684.png)

![image-20221025165315768](./img/image-20221025165315768.png)

## 用户线程和守护线程

![image-20221025171111819](./img/image-20221025171111819.png)

![image-20221025171231393](./img/image-20221025171231393.png)

## 同步和互斥

![image-20221025175300939](./img/image-20221025175300939.png)

线程生命周期：

![image-20221025185127609](./img/image-20221025185127609.png)

## 线程同步和互斥锁

简介：互斥访问一个资源，在一个时间内只允许一个线程进入操作资源

### 线程同步机制

+ 在多线程编程时，一些敏感数据的操作顺序可能由于操作系统CPU调度的影响而不同，线程同步就是保证各个线程根据设计按步骤执行。

### 互斥锁

#### 基本介绍

1. JAVA语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性；
2. 每个对象都对应于一个可称为 “互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象；
3. 关键字 synchronized与对象的互斥锁联系；当某个对象用 synchronized修饰时，表明该对象在任一时刻只能由一个线程访问；
4. 同步的局限性：导致程序的执行效率要降低；
5. 同步方法（非静态）的锁可以是 this，也可以是其他对象（实现互斥访问要求这个锁是同一个对象）；
6. 同步方法（静态）的锁只能是当前类本身（即class对象）。

#### 注意事项和细节

1. 同步方法如果没有使用 static修饰；默认锁对象为 this
2. 如果方法使用 static修饰，默认锁对象：当前类.class

#### 同步代码块和同步方法

同步代码块的好处就是精确控制需要锁的地方，尽量不要损失太多效率

例子：

![image-20221025191943407](./img/image-20221025191943407.png)

没有获得当前锁对象的线程只能被阻塞在 `synchronized (this)`这句话之前

![image-20221025192442219](./img/image-20221025192442219.png)

```java
1.同步代码块
synchronized (对象){ // 得到对象的锁，才能操作同步代码
	// 需要被同步的代码；
}

2.synchronized 放在方法声明中，表示整个方法，即同步方法
public synchronized void method (String name){
	// 需要被同步的代码
}
```

### 锁的释放和不释放

#### 会释放锁的操作

1. 当前线程的同步方法、同步代码块执行结束；
2. 当前线程在同步代码块、同步方法中遇到 break、return；
3. 当前线程在同步代码块、同步方法中出现了未处理的 Error或 Exception，导致异常结束；
4. 当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁。

#### 不会释放锁的操作

1. 线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁；

2. 线程执行同步代码块时，其他线程调用了该线程的 suspend()方法将该线程挂起，该线程不会释放锁。

   <font color=red size=3>**注：**</font>应尽量避免使用suspend()和 resume()来控制线程，这两个方法已经过时，不推荐使用。