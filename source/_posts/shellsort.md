---
title: 希尔排序算法思想和简单实现
date: 2022-09-27 14:53
tags: 
- tech
- algorithm
- data_structure
---
# 希尔排序

目的：用这篇文章来记录和巩固希尔排序的思想和实现步骤

## 基本思想：

​	先将整个待排序列分割成**若干子序列**，分别进行直接插入排序，代整个序列中的记录"**基本有序**"时，再对全体记录进行一次**直接插入排序**。

### 希尔排序算法的特点

+ 缩小增量
+ 多遍插入排序

## 希尔排序特点

+ 一次移动，移动位置较大，跳跃式地接近排序后的最终位置
+ 最后一次只需要少量移动
+ 增量序列必须是递减的，最后一个必须是1
+ 增量序列应该是互质的(不能互相整除)

----



## 算法实现

### 主程：

用来给定需要进行希尔排序的序列、增量序列和进行排序的次数

示例代码如下：

```c++
#define MAXSIZE 20
typedef char InfoType;
// 数据结构
typedef struct{ // 每个记录的数据结构
    int key; // 关键字
    InfoType otherInfo;
}RedType； // Record Type
typedef struct{ // 顺序表的数据结构
    RedType r[MAXSIZE + 1]; // r[0] 通常用来作为哨兵，数据存储的位置从下标为 1的位置开始开始
    int length; // 保存顺序表的长度
}Sqlist;

void ShellSort(Sqlist &L, int dlta[], int t){
	// 按增量序列dlta[0...t-1]对顺序表L做希尔排序
	for(int i = 0; i < t; ++i)
		ShellInsert(L, dlta[i]); // 一趟增量为dlta[i]的插入排序
} // ShellSort
```

增量的意思是每次执行排序的两个数之间的距离。

![image-20220927115831072](./img/image-20220927115831072.png)

数据为0的位置为哨兵的位置，这里的哨兵并不是直接插入排序中的哨兵，这里的哨兵来进行辅助交换操作。

<!-- more -->

### 增量排序：

```c++
void ShellInsert(Sqlist &L, int dk){
	// 对顺序表进行一趟增量为dk的Shell排序，dk为这次增量排序的步长
    int i, j;
	for(i = dk + 1; i <= L.length; ++i){
        if(L.r[i].key < L.r[i - dk].key){
            L.r[0] = L.r[i]; // 用哨兵暂存扫描到且还没加到有序表的元素
            // j = j -dk用来判断之前是否有元素，如果有，之前的元素也需要跟交换后的位置比较，以保持有序性质
            for(j = i - dk; j > 0 && (L.r[0].key < L.r[j].key); j = j - dk)
                L.r[j + dk] = L.r[j];
            L.r[j + dk] = L.r[0];
        }
    }
}
```

没有什么比举例子更容易理解的东西

![image-20220927122439367](./img/image-20220927122439367.png)

eg：

+ **第一轮循环**：当dk为5时，希尔排序从dk + 1的位置开始开始比较第 dk + 1 和dk + 1 - dk的大小，第一轮循环，比较下图中的两个位置的大小并交换。

开始状态：

![image-20220927122737873](./img/image-20220927122737873.png)

执行完第一轮循环之后的状态：

​		此时 **j = i - dk，也就是说 j 也指向 i - dk的位置，执行完 交换之后需要 减去一个dk（也就是减去一个步长），再看看前面是否还有需要交换的元素，以来保证每次循环后，i之前的相距 dk的位置是相对有序的**

![image-20220927124121257](./img/image-20220927124121257.png)

![image-20220927124522670](./img/image-20220927124522670.png)

+ 当 **i - dk****的值小于**0**时，表明前面没有需要比较的元素，只需要对比两元素之后，**i**跳转到下一个暂未排序的增量步长

+ 当 **i - dk****的值大于**0**时，表明前面还有需要比较的元素，如下图

  当 **i**的位置在下午所示的位置时候。

![image-20220927144605396](./img/image-20220927144605396.png)

+ 由于此时在 **j**之前的元素都已排好序，则不需要进行位置交换，即跳出循环，完成排序；其他位置的比较和交换类似。自己模拟一下就知道了。

### 注：增量序列可能有很多个，所以每次的增量排序都跟上诉过程类似，要注意的是，之后一次的排序一定是直接插入排序，但是因为这时整个表相对有序，所以有更好的性能



## 参考：青岛大学--王卓，地址：https://space.bilibili.com/40323036

